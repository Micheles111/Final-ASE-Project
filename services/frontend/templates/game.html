<!DOCTYPE html>
<html>
<head>
    <title>Play Match</title>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #2e7d32; 
            background-image: radial-gradient(#388e3c, #1b5e20);
            color: white; 
            padding: 20px; 
            text-align: center; 
            min-height: 100vh;
            margin: 0;
        }
        .game-container { max-width: 1100px; margin: 0 auto; position: relative; }
        
        .area { padding: 10px; border-radius: 15px; margin: 10px 0; min-height: 160px; display: flex; justify-content: center; align-items: center; }
        .cards-row { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; }
        
        .score-bar {
            display: flex; justify-content: center; gap: 20px; margin-bottom: 20px;
            background: rgba(0,0,0,0.4); padding: 10px; border-radius: 10px;
        }
        .score-box {
            background: rgba(255,255,255,0.9); color: #333; padding: 5px 15px; 
            border-radius: 5px; font-weight: bold; min-width: 100px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .score-active { border: 3px solid #ffeb3b; }

        .card-wrapper { position: relative; width: 100px; height: 152px; transition: transform 0.2s; cursor: pointer; }
        .card-img { width: 100%; height: 100%; border-radius: 8px; box-shadow: 2px 4px 8px rgba(0,0,0,0.5); object-fit: cover; background-color: white; }
        .card-fallback { width: 100%; height: 100%; background: white; color: black; border-radius: 8px; display: flex; flex-direction: column; justify-content: center; align-items: center; border: 2px solid #ccc; font-weight: bold; font-size: 14px; position: absolute; top: 0; left: 0; }
        .clickable:hover { transform: translateY(-15px) scale(1.05); z-index: 10; }
        .selected .card-img, .selected .card-fallback { outline: 4px solid #ffeb3b; box-shadow: 0 0 20px #ffeb3b; }
        
        #status-msg { font-size: 1.2rem; margin: 15px auto; font-weight: bold; background: rgba(0,0,0,0.7); padding: 10px 30px; border-radius: 50px; display: inline-block; border: 1px solid rgba(255,255,255,0.3); backdrop-filter: blur(5px); }
        
        button { padding: 12px 40px; font-size: 1.2rem; background: linear-gradient(to bottom, #ff9800, #f57c00); color: white; border: none; border-radius: 50px; cursor: pointer; margin-top: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); font-weight: bold; transition: all 0.2s; }
        button:hover:not(:disabled) { transform: scale(1.05); filter: brightness(1.1); }
        button:disabled { background: #bdbdbd; cursor: not-allowed; transform: none; box-shadow: none; }

        .header-bar { display: flex; justify-content: space-between; align-items: center; background: rgba(0,0,0,0.3); padding: 10px 20px; border-radius: 10px; margin-bottom: 20px; }
        
        .deck-info { position: absolute; top: 100px; left: 20px; text-align: center; }
        .deck-count { background: white; color: black; border-radius: 50%; width: 30px; height: 30px; display: flex; justify-content: center; align-items: center; font-weight: bold; position: absolute; top: -10px; right: -10px; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .surrender-btn-game { background: linear-gradient(to bottom, #d32f2f, #b71c1c) !important; font-size: 1rem; padding: 8px 20px; margin-left: 20px; }
        
        /* OVERLAY PASS DEVICE */
        #pass-device-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.98); z-index: 999;
            display: none; justify-content: center; align-items: center; flex-direction: column;
        }
        #pass-device-overlay h1 { font-size: 2.5rem; margin-bottom: 20px; color: #fff; }
        #pass-btn { font-size: 1.5rem; padding: 20px 50px; }
        
        #countdown-text { font-size: 5rem; font-weight: bold; color: #ffeb3b; margin-top: 20px; display: none; }
        .overlay-instruction { color: #aaa; margin-bottom: 30px; font-size: 1.2rem; }

        /* END OF GAME ACTION AREA */
        #end-game-actions {
            margin-top: 20px;
            display: none;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        .btn-add-friend { background: #2196f3; font-size: 1rem; padding: 10px 25px; }
        .btn-rematch { background: #673ab7; font-size: 1rem; padding: 10px 25px; }
        
        /*Style for reaction buttons*/
        .reaction-btn {
            background: rgba(255, 255, 255, 0.2); 
            font-size: 1.5rem; 
            padding: 5px 10px; 
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            box-shadow: none;
            cursor: pointer;
            transition: background 0.1s;
        }
        .reaction-btn:hover { 
            background: rgba(255, 255, 255, 0.4); 
        }
        
        /* Style for the floating reaction sign */
        .reaction-display {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 1.2rem;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            pointer-events: none;
        }
        
        /* Positioning: Adjust these values ‚Äã‚Äãso they appear above the hands/names */
        #my-reaction { bottom: 200px; left: 50%; transform: translateX(-50%); }
        #opp-reaction { top: 200px; left: 50%; transform: translateX(-50%); }
    </style>
    </head>
<body>
    
    <div id="pass-device-overlay">
        <h1 id="overlay-title">üì± Pass Device</h1>
        <p class="overlay-instruction">Hand device to <strong id="next-player-name" style="color: #ffeb3b;"></strong></p>
        <button id="pass-btn" onclick="startCountdown()">Passa il Turno</button>
        <div id="countdown-text">5</div>
    </div>

    <div class="game-container">
        <div class="header-bar">
            <div><a href="/dashboard" style="color: white; text-decoration: none; font-weight: bold;">&larr; Dashboard</a></div>
            <span>Logged in as: <strong style="color: #ffeb3b;">{{ user }}</strong></span>
            <form id="surrender-form" action="/surrender/{{ match_id }}" method="POST" style="margin: 0;" onsubmit="return confirm('Surrender this match?');">
                <button type="submit" class="surrender-btn-game">üè≥Ô∏è Surrender</button>
            </form>
        </div>

        <div class="score-bar" id="scoreboard">
            <div class="score-box" id="score-me">Me: 0</div>
            <div class="score-box" id="score-opp">Opponent: 0</div>
        </div>

        <div class="deck-info">
            <div style="position: relative;">
                <img src="/static/cards/back.png" width="60" style="border-radius: 5px; box-shadow: 2px 2px 5px rgba(0,0,0,0.5);">
                <div class="deck-count" id="deck-remaining">?</div>
            </div>
            <small>Deck</small>
        </div>

        <div id="opponent-name-label" style="font-size: 0.9rem; opacity: 0.8;">Opponent</div>
        <div id="opponent-hand" class="cards-row area" style="min-height: 120px;"></div>

        <div style="font-size: 0.9rem; opacity: 0.8;">Table</div>
        <div id="table-cards" class="cards-row area" style="background: rgba(255,255,255,0.15); border: 2px dashed rgba(255,255,255,0.3);"></div>

        <div id="status-msg">Loading game...</div>

        <div id="turn-timer" style="font-size: 1.5rem; color: #ffeb3b; font-weight: bold; margin: 10px auto; display: none;">
            üïí <span id="timer-value">00:00</span>
        </div>

        <div id="end-game-actions">
            <form action="/create_match" method="POST">
                <input type="hidden" name="opponent" id="rematch-opponent-input">
                <button type="submit" class="btn-rematch">üîÑ Request Rematch</button>
            </form>
            
            <form action="/friends/add" method="POST" id="friend-form" style="display:none;">
                <input type="hidden" name="username" id="friend-input">
                <button type="submit" class="btn-add-friend">‚ûï Add Opponent to Friends</button>
            </form>
        </div>
        
        <div id="reaction-panel" style="margin-top: 15px; display: flex; justify-content: center; gap: 10px;">
            <button type="button" class="reaction-btn" onclick="sendReaction('üòÇ')">üòÇ</button>
            <button type="button" class="reaction-btn" onclick="sendReaction('ü§ó‚Äã')">ü§ó‚Äã</button>
            <button type="button" class="reaction-btn" onclick="sendReaction('üòã‚Äã')">üòã‚Äã</button>
            <button type="button" class="reaction-btn" onclick="sendReaction('ü§î')">ü§î</button>
            <button type="button" class="reaction-btn" onclick="sendReaction('üò≥‚Äã')">üò≥‚Äã</button>
            <button type="button" class="reaction-btn" onclick="sendReaction('üò°‚Äã')">üò°‚Äã</button>
        </div>

        <div class="reaction-display" id="my-reaction"></div>
        <div class="reaction-display" id="opp-reaction"></div>

        <div id="my-name-label" style="font-size: 0.9rem; opacity: 0.8;">Your Hand</div>
        <div id="my-hand" class="cards-row area"></div>

        <button id="play-btn" onclick="playCard()" disabled>Select a Card</button>
    </div>

    <script>
        const matchId = "{{ match_id }}";
        const currentUser = "{{ user }}";
        const isLocal = {{ 'true' if local else 'false' }};
        // Jinja populates this list with current friends
        const currentFriends = {{ current_friends | tojson }};

        let lastReactionTimestamp = null;
        let selectedCardId = null;
        let isMyTurn = false;
        let lastTurnPlayer = null;
        let currentVisualPlayer = currentUser;
        let turnStartTime = null;
        let timerInterval = null;

        function getCardData(id) {
            if(id === "hidden") return { url: "/static/cards/back.png", alt: "Back" };
            const suits = ["oro", "copas", "espadas", "bastos"];
            const suitIndex = Math.floor((id - 1) / 10);
            const suitName = suits[suitIndex];
            let valIndex = (id - 1) % 10 + 1;
            let prefix = valIndex;
            if (valIndex === 8) prefix = "sota";
            if (valIndex === 9) prefix = "caballo";
            if (valIndex === 10) prefix = "rey";
            return { url: `/static/cards/${prefix}_${suitName}.png`, alt: `${prefix} ${suitName}` };
        }

        async function updateGameState() {
            try {
                let queryParam = `player=${currentVisualPlayer}`;
                const response = await fetch(`/api/proxy/match/${matchId}?${queryParam}`);
                const data = await response.json();
                

                if (data.last_reaction && data.last_reaction.timestamp !== lastReactionTimestamp) {
                    const reaction = data.last_reaction;
                    
                    // If the reaction is new, display it
                    lastReactionTimestamp = reaction.timestamp; 
                    displayReaction(playerWhoReacted, emoji);
                }

                if(data.status === 'finished') {
                    stopTimer();
                    const statusEl = document.getElementById('status-msg');
                    statusEl.innerHTML = `üèÜ MATCH OVER! Winner: ${data.result.winner}`;
                    statusEl.style.backgroundColor = "#d32f2f";
                    
                    renderCards('opponent-hand', [], false); 
                    renderCards('table-cards', [], false);
                    renderCards('my-hand', [], false);
                    
                    document.getElementById('play-btn').style.display = 'none';
                    document.querySelector('.deck-info').style.display = 'none';
                    document.getElementById('surrender-form').style.display = 'none';
                    document.getElementById('pass-device-overlay').style.display = 'none';

                    // Show end game actions
                    const oppName = Object.keys(data.players).find(p => p !== currentUser);
                    document.getElementById('end-game-actions').style.display = 'flex';
                    
                    // Configurate Rematch
                    document.getElementById('rematch-opponent-input').value = oppName;
                    
                    // Show Add Friend if not already friends
                    if(oppName !== 'CPU' && oppName !== 'Guest' && !currentFriends.includes(oppName)) {
                        document.getElementById('friend-input').value = oppName;
                        document.getElementById('friend-form').style.display = 'block';
                    }
                    setTimeout(() => {
                        window.location.href = "/dashboard";
                    }, 1000);

                    return;
                }

                // Local shift change management
                if(isLocal && lastTurnPlayer && lastTurnPlayer !== data.turn) {
                    document.getElementById('next-player-name').innerText = data.turn;
                    document.getElementById('pass-device-overlay').style.display = 'flex';
                    document.getElementById('pass-btn').style.display = 'block';
                    document.getElementById('countdown-text').style.display = 'none';
                    document.getElementById('overlay-title').innerText = "üì± Pass Device";
                    lastTurnPlayer = data.turn;
                    return; 
                }
                
                if(isLocal && !lastTurnPlayer) {
                    lastTurnPlayer = data.turn;
                    currentVisualPlayer = data.turn; 
                }

                const p1 = Object.keys(data.players)[0];
                const p2 = Object.keys(data.players)[1];
                if (data.current_scores) {
                    document.getElementById('score-me').innerText = `${p1}: ${data.current_scores[p1] || 0}`;
                    document.getElementById('score-opp').innerText = `${p2}: ${data.current_scores[p2] || 0}`;
                }
                if (data.cards_remaining !== undefined) {
                    document.getElementById('deck-remaining').innerText = data.cards_remaining;
                }

                isMyTurn = (data.turn === currentVisualPlayer);
                
                if (isMyTurn && data.turn_start_time) {
                    startTimer(data.turn_start_time);
                } else {
                    stopTimer();
                }

                const statusDiv = document.getElementById('status-msg');

                if(isMyTurn) {
                    statusDiv.innerHTML = `üü¢ ${currentVisualPlayer}'s TURN`;
                    statusDiv.style.borderColor = "#4caf50";
                } else {
                    statusDiv.innerHTML = `‚è≥ Waiting for ${data.turn}`;
                    statusDiv.style.borderColor = "#f44336";
                }

                const myHand = data.players[currentVisualPlayer].hand;
                const oppName = Object.keys(data.players).find(p => p !== currentVisualPlayer);
                const oppHand = data.players[oppName].hand;

                document.getElementById('my-name-label').innerText = `${currentVisualPlayer}'s Hand`;
                document.getElementById('opponent-name-label').innerText = `${oppName}`;

                if (isLocal) {
                    const hiddenHand = new Array(oppHand.length).fill("hidden");
                    renderCards('opponent-hand', hiddenHand, false);
                } else {
                    renderCards('opponent-hand', oppHand, false);
                }
                
                renderCards('table-cards', data.table, false);
                renderCards('my-hand', myHand, true);

            } catch (error) {
                console.error("Error fetching state:", error);
            }
        }

        function startCountdown() {
            document.getElementById('pass-btn').style.display = 'none';
            const countDiv = document.getElementById('countdown-text');
            countDiv.style.display = 'block';
            document.getElementById('overlay-title').innerText = "Get Ready...";
            let seconds = 5;
            countDiv.innerText = seconds;
            const interval = setInterval(() => {
                seconds--;
                countDiv.innerText = seconds;
                if (seconds <= 0) {
                    clearInterval(interval);
                    document.getElementById('pass-device-overlay').style.display = 'none';
                    currentVisualPlayer = lastTurnPlayer;
                    updateGameState();
                }
            }, 1000);
        }

        function renderCards(elementId, cardIds, clickable) {
            const container = document.getElementById(elementId);
            container.innerHTML = '';
            cardIds.forEach(id => {
                const wrapper = document.createElement('div');
                wrapper.className = 'card-wrapper';
                if(clickable && isMyTurn) wrapper.classList.add('clickable');
                const cardData = getCardData(id);
                const img = document.createElement('img');
                img.src = cardData.url;
                img.className = 'card-img';
                img.onerror = function() {
                    this.style.display = 'none';
                    const fallback = document.createElement('div');
                    fallback.className = 'card-fallback';
                    fallback.innerHTML = `<span>${cardData.alt}</span>`; 
                    wrapper.appendChild(fallback);
                };
                wrapper.appendChild(img);
                if(clickable && isMyTurn) {
                    wrapper.onclick = () => selectCard(id, wrapper);
                    if(selectedCardId === id) wrapper.classList.add('selected');
                }
                container.appendChild(wrapper);
            });
        }

        function selectCard(id, element) {
            document.querySelectorAll('.card-wrapper.selected').forEach(el => el.classList.remove('selected'));
            selectedCardId = id;
            element.classList.add('selected');
            const btn = document.getElementById('play-btn');
            btn.disabled = false;
            btn.innerText = "Play Card";
        }

        async function playCard() {
            if(!selectedCardId) return;
            const btn = document.getElementById('play-btn');
            btn.disabled = true;
            btn.innerText = "Sending...";
            try {
                const playerToSend = isLocal ? currentVisualPlayer : currentUser;
                const response = await fetch(`/api/proxy/play/${matchId}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ player: playerToSend, card_id: selectedCardId })
                });
                const result = await response.json();
                if(response.ok) {
                    selectedCardId = null;
                    btn.innerText = "Select a Card";
                    updateGameState();
                } else {
                    alert("Error: " + result.error);
                    btn.disabled = false;
                    btn.innerText = "Play Card";
                }
            } catch (error) {
                console.error(error);
                btn.disabled = false;
            }
        }

        // Function for sending reactions to the server
        async function sendReaction(emoji) {
            const playerToSend = isLocal ? currentVisualPlayer : currentUser;
            
            try {
                const response = await fetch(`/api/proxy/match/${matchId}/react`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ 
                        player: playerToSend, 
                        reaction: emoji 
                    })
                });
                
                if (response.ok) {
                    // Esto muestra el emoji localmente al instante para dar feedback
                    displayReaction(playerToSend, emoji);
                } else {
                    console.error("Error en el servidor al enviar reacci√≥n");
                }
            } catch (error) {
                console.error("Error de red al enviar reacci√≥n:", error);
            }
        } 

        function displayReaction(player, reactionContent) {
            // Determinar si la reacci√≥n es del jugador actual o del oponente
            // currentUser es la variable global definida al principio del script
            const isMe = (player === currentVisualPlayer); 
            const displayEl = isMe ? document.getElementById('my-reaction') : document.getElementById('opp-reaction');
            
            if (!displayEl) return;

            // 1. Resetear estado por si hab√≠a una animaci√≥n previa
            displayEl.style.transition = 'none';
            displayEl.style.opacity = '0';
            displayEl.innerText = reactionContent;
            
            // 2. Forzar un peque√±o reflow para que el navegador note el reset
            displayEl.offsetHeight; 

            // 3. Aplicar la animaci√≥n
            displayEl.style.transition = 'opacity 0.5s, transform 0.5s';
            displayEl.style.opacity = '1';
            
            // Movimiento hacia arriba si soy yo, hacia abajo si es el oponente
            const moveY = isMe ? '-40px' : '40px';
            displayEl.style.transform = `translateX(-50%) translateY(${moveY})`;
            
            // 4. Desvanecer despu√©s de 3 segundos
            setTimeout(() => {
                displayEl.style.opacity = '0';
                displayEl.style.transform = 'translateX(-50%) translateY(0)';
            }, 3000);
        }

        // Function to start the turn timer
        function startTimer(startTimeString) {
            if (timerInterval) clearInterval(timerInterval);
            
            const timerDiv = document.getElementById('turn-timer');
            const timerValueSpan = document.getElementById('timer-value');
            
            if (!isMyTurn) {
                timerDiv.style.display = 'none';
                return;
            }

            timerDiv.style.display = 'block';
            
            // Forzar que la cadena se interprete como UTC a√±adiendo una 'Z' si no la tiene
            let isoString = startTimeString;
            if (!isoString.endsWith('Z')) isoString += 'Z';
            turnStartTime = new Date(isoString);

            function updateTimerDisplay() {
                const now = new Date(); // Esto da la hora actual en local
                // Convertimos 'now' a milisegundos UTC para la comparacion
                const nowUTC = now.getTime() + (now.getTimezoneOffset() * 60000);
                // O m√°s simple, usar el valor absoluto de la resta si los objetos Date est√°n bien formados:
                const elapsedMilliseconds = Math.abs(now - turnStartTime);
                
                const totalSeconds = Math.floor(elapsedMilliseconds / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;

                // Si el desfase sigue ocurriendo, forzamos a que solo muestre minutos menores a 60
                const minutesDisplay = minutes % 60; 

                const formattedTime = `${String(minutesDisplay).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                timerValueSpan.innerText = formattedTime;
            }

            updateTimerDisplay();
            timerInterval = setInterval(updateTimerDisplay, 1000); 
        }

        // Function to stop the timer
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            document.getElementById('turn-timer').style.display = 'none';
            document.getElementById('timer-value').innerText = '00:00';
        }

        setInterval(updateGameState, 2000);
        updateGameState();
    </script>
</body>
</html>